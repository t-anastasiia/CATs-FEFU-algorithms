//      Задача B0. Мёд и справедливость
//Автор:	Кленин А. С.	 	Ограничение времени:	1 сек
//Входной файл:	Стандартный вход	 	Ограничение памяти:	512 Мб
//Выходной файл:	Стандартный выход
//      Условие
//Две пчелы собирают пыльцу с N цветков, расположенных в ряд. Цветок номер i содержит ai микрограмм пыльцы.
//Пчёлы договорились, что первая пчела будет собирать пыльцу с цветков на участке от L до M включительно, а вторая  — от
//M+1 до R включительно (L≤M<R). Чтобы ни одной из пчёл не было обидно, сумма запасов пыльцы на первом и втором
//участках пчёл должны совпадать.
//Требуется написать программу, которая найдёт подходящие участки с наибольшим возможным количеством пыльцы.
//      Формат входных данных
//Входные данные содержат целое число N, за которым следует N чисел ai.
//      Формат выходных данных
//Выходные данные должны содержать целые числа L M R — границы участков. Если оптимальных решений несколько, выведите
//решение с наименьшим значением L. Если решения не существует, выведите единственное число − 1.
//      Ограничения
//2 ≤ N ≤ 10000
//1 ≤ ai ≤ 10^5

#include <iostream>
#include <vector>
using namespace std;

int main() {
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);

    int N;
    cin >> N;
    vector<int> array(N);
    for (int i = 0; i < N; ++i) {
        cin >> array[i];
    }

    int L = 0, M = 0, R = 0, honey = 0;
    vector<int> Lm(N - 1, 0);
    vector<int> Rm(N, 0);

    for (int m = 0; m < N - 1; ++m) {
        Lm[0] += array[m];
        for (int l = 1; l < m + 1; ++l) {
            Lm[l] = Lm[l - 1] - array[l - 1];
        }

        Rm[m + 1] = array[m + 1];
        for (int r = m + 2; r < N; ++r) {
            Rm[r] = Rm[r - 1] + array[r];
        }

        int RmI = N - 1;
        for (int l = 0; l < m + 1; ++l) {
            while (RmI > m) {
                if (Rm[RmI] == Lm[l]) {
                    if (Rm[RmI] > honey) {
                        L = l;
                        M = m;
                        R = RmI;
                        honey = Rm[RmI];
                    } else if (Rm[RmI] == honey && l < L) {
                        L = l;
                        M = m;
                        R = RmI;
                    }
                    break;
                }
                if (Rm[RmI - 1] < Lm[l]) {
                    break;
                }
                --RmI;
            }
        }
    }

    if (honey == 0) {
        cout << "-1";
        return 0;
    }

    cout << L + 1 << " " << M + 1 << " " << R + 1;
    return 0;
}
